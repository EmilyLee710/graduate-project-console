"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var ts = require("typescript");
var path_1 = require("path");
// camel2Dash camel2Underline
// borrow from https://github.com/ant-design/babel-plugin-import
function camel2Dash(_str) {
    var str = _str[0].toLowerCase() + _str.substr(1);
    return str.replace(/([A-Z])/g, function ($1) { return "-" + $1.toLowerCase(); });
}
function camel2Underline(_str) {
    var str = _str[0].toLowerCase() + _str.substr(1);
    return str.replace(/([A-Z])/g, function ($1) { return "_" + $1.toLowerCase(); });
}
function getImportedLibName(node) {
    var childCount = node.getChildCount();
    var lastChild = node.getChildAt(childCount - 1);
    if (lastChild.kind === ts.SyntaxKind.SemicolonToken) {
        lastChild = node.getChildAt(childCount - 2);
    }
    return lastChild.getText().replace(/"/g, '\'');
}
function getImportedStructs(node) {
    var structs = new Set();
    node.forEachChild(function (importChild) {
        if (importChild.kind === ts.SyntaxKind.ImportClause) {
            importChild.getChildAt(0).forEachChild(function (child) {
                var childCount = child.getChildCount();
                if (!childCount) {
                    return;
                }
                if (childCount !== 1) {
                    var importName = child.getChildAt(0).getText();
                    var variableName = child.getChildAt(2).getText();
                    structs.add({
                        importName: importName,
                        variableName: variableName
                    });
                }
                else {
                    var name_1 = child.getText();
                    structs.add({ importName: name_1 });
                }
            });
        }
    });
    return structs;
}
function createDistAst(struct, options) {
    var astNodes = [];
    var libraryName = options.libraryName;
    var _importName = struct.importName;
    var importName = options.camel2UnderlineComponentName ?
        camel2Underline(_importName) :
        options.camel2DashComponentName ?
            camel2Dash(_importName) :
            _importName;
    var libraryDirectory = typeof options.libraryDirectory === 'function' ?
        options.libraryDirectory(_importName) :
        path_1.join((options.libraryDirectory || ''), importName);
    /* istanbul ignore next  */
    if (process.env.NODE_ENV !== 'production') {
        if (libraryDirectory == null) {
            console.warn("custom libraryDirectory resolve a " + libraryDirectory + " path");
        }
    }
    var importPath = path_1.join(libraryName, libraryDirectory);
    var scriptNode = ts.createImportDeclaration(undefined, undefined, ts.createImportClause(struct.variableName || !options.transformToDefaultImport ? undefined : ts.createIdentifier(struct.importName), struct.variableName ? ts.createNamedImports([
        ts.createImportSpecifier(options.transformToDefaultImport ? ts.createIdentifier('default') : ts.createIdentifier(struct.importName), ts.createIdentifier(struct.variableName))
    ]) : options.transformToDefaultImport ? undefined : ts.createNamedImports([
        ts.createImportSpecifier(undefined, ts.createIdentifier(struct.importName))
    ])), ts.createLiteral(importPath));
    astNodes.push(scriptNode);
    if (options.style) {
        var style = options.style, styleExt = options.styleExt;
        var styleNode = ts.createImportDeclaration(undefined, undefined, undefined, ts.createLiteral(importPath + "/style/" + (style === 'css' ? (styleExt ? styleExt : 'css') : 'index') + ".js"));
        astNodes.push(styleNode);
    }
    return astNodes;
}
var defaultOptions = {
    libraryName: 'antd',
    libraryDirectory: 'lib',
    style: false,
    camel2DashComponentName: true,
    transformToDefaultImport: true
};
function createTransformer(_options) {
    if (_options === void 0) { _options = {}; }
    var mergeDefault = function (options) { return (tslib_1.__assign({}, defaultOptions, options)); };
    var optionsArray = Array.isArray(_options) ? _options.map(function (options) { return mergeDefault(options); }) : [mergeDefault(_options)];
    var transformer = function (context) {
        var visitor = function (node) {
            if (node.kind === ts.SyntaxKind.SourceFile) {
                return ts.visitEachChild(node, visitor, context);
            }
            if (node.kind !== ts.SyntaxKind.ImportDeclaration) {
                return node;
            }
            var importedLibName = getImportedLibName(node);
            var options = optionsArray.find(function (_) { return "'" + _.libraryName + "'" === importedLibName; });
            if (!options) {
                return node;
            }
            var structs = getImportedStructs(node);
            if (structs.size === 0) {
                return node;
            }
            return Array
                .from(structs)
                .reduce(function (acc, struct) {
                var nodes = createDistAst(struct, options);
                return acc.concat(nodes);
            }, []);
        };
        return function (node) { return ts.visitNode(node, visitor); };
    };
    return transformer;
}
exports.createTransformer = createTransformer;
exports.default = createTransformer;
//# sourceMappingURL=index.js.map